; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -odatalogger5.o --depend=datalogger5.d --device=DARMAD -I.\inc -I.\efsl-0.2.8\inc -I.\efsl-0.2.8\conf -IC:\Keil\ARM\INC\ADI -D__MICROLIB -D__KEIL__ datalogger5.c]
                          ARM

                          AREA ||i.DAbt_Handler||, CODE, READONLY, ALIGN=2

                  DAbt_Handler PROC
;;;254    
;;;255    void DAbt_Handler() __irq 
000000  e92d500f          PUSH     {r0-r3,r12,lr}
;;;256    {
;;;257    	DEBUG_PRINTF("MYDABORT\n");
000004  e28f0014          ADR      r0,|L1.32|
000008  ebfffffe          BL       debug_printf
;;;258    	greenLight(false);
00000c  e3a00000          MOV      r0,#0
000010  ebfffffe          BL       greenLight
;;;259    	redLight(true);
000014  e3a00001          MOV      r0,#1
000018  ebfffffe          BL       redLight
                  |L1.28|
;;;260    	while (true);
00001c  eafffffe          B        |L1.28|
;;;261    }
;;;262    
                          ENDP

                  |L1.32|
000020  4d594441424f52540a00        DCB      "MYDABORT\n",0
00002a  00                DCB      0
00002b  00                DCB      0

                          AREA ||i.FIQ_Handler||, CODE, READONLY, ALIGN=2

                  FIQ_Handler PROC
;;;238    
;;;239    void FIQ_Handler() __irq
000000  e92d500f          PUSH     {r0-r3,r12,lr}
;;;240    {
;;;241    	DEBUG_PRINTF("MYFIQ\n");
000004  e28f0014          ADR      r0,|L2.32|
000008  ebfffffe          BL       debug_printf
;;;242    	greenLight(false);
00000c  e3a00000          MOV      r0,#0
000010  ebfffffe          BL       greenLight
;;;243    	redLight(true);
000014  e3a00001          MOV      r0,#1
000018  ebfffffe          BL       redLight
                  |L2.28|
;;;244    	while (true);
00001c  eafffffe          B        |L2.28|
;;;245    }
;;;246    
                          ENDP

                  |L2.32|
000020  4d594649510a00        DCB      "MYFIQ\n",0
000027  00                DCB      0

                          AREA ||i.IRQ_Handler||, CODE, READONLY, ALIGN=2

                  IRQ_Handler PROC
;;;157    
;;;158    void IRQ_Handler(void) __irq
000000  e92d51ff          PUSH     {r0-r8,r12,lr}
;;;159    {
;;;160    	//DEBUG_PRINTF("MYISR [irqsig=0x%08lX] [t=%d]\n", IRQSIG, T2VAL);
;;;161    
;;;162    	// 0x0040A000
;;;163    	// 0000 0000 0100 0000 1010 0000 0000 0000
;;;164    	// 13, 15, 22
;;;165    //	int t1, t2, t3 = 0;
;;;166    	unsigned char interruptSource;
;;;167    
;;;168    //    T2CON = 0x00000500;
;;;169    	num_of_int++; // count number of interrutps
000004  e59f6118          LDR      r6,|L3.292|
000008  e24dd014          SUB      sp,sp,#0x14           ;159
00000c  e5960004          LDR      r0,[r6,#4]  ; num_of_int
;;;170    
;;;171    	xl345Read(1, XL345_INT_SOURCE, &interruptSource);
000010  e28d2010          ADD      r2,sp,#0x10
000014  e2800001          ADD      r0,r0,#1              ;169
000018  e5860004          STR      r0,[r6,#4]  ; num_of_int
00001c  e3a01030          MOV      r1,#0x30
000020  e3a00001          MOV      r0,#1
000024  ebfffffe          BL       xl345Read
;;;172    	if (interruptSource & XL345_OVERRUN) {
000028  e5dd1010          LDRB     r1,[sp,#0x10]
00002c  e3110001          TST      r1,#1
;;;173    //		DEBUG_PRINTF("Overrun @ %d\n", T2VAL);
;;;174    		overrun_flag = 1;
000030  13a00001          MOVNE    r0,#1
000034  15860000          STRNE    r0,[r6,#0]  ; overrun_flag
;;;175    	}
;;;176    
;;;177    	if (interruptSource & XL345_WATERMARK) {
000038  e3110002          TST      r1,#2
00003c  0a000035          BEQ      |L3.280|
;;;178    
;;;179    		//DEBUG_PRINTF("***\n*** About to read some fifo data\n***\n");
;;;180    		unsigned char count = 0;					   // (JWS) old was an int
000040  e3a05000          MOV      r5,#0
;;;181    		unsigned char entryCount = 0;
;;;182    		unsigned char databuf[8];
;;;183    		int thisTime = T2VAL;
000044  e2450801          SUB      r0,r5,#0x10000
000048  e58d500c          STR      r5,[sp,#0xc]
00004c  e5908344          LDR      r8,[r0,#0x344]
000050  e1a07005          MOV      r7,r5                 ;181
;;;184    
;;;185    
;;;186    		xl345Read(1, XL345_FIFO_STATUS, &entryCount);	 // read the number of values in the FIFO of the ADXL sensor
000054  e28d200c          ADD      r2,sp,#0xc
000058  e3a01039          MOV      r1,#0x39
00005c  e3a00001          MOV      r0,#1
000060  ebfffffe          BL       xl345Read
;;;187    //		entryCount = 31;	// fix the entry count as reading from the sensor can alway fall between samples and give a +/- 1 sample error.
;;;188    
;;;189    		// get the lower 6 bits
;;;190    		entryCount &= 0x3f;
000064  e5dd000c          LDRB     r0,[sp,#0xc]
;;;191    		for (count = 0; count < entryCount; count++) {
;;;192    			short x1, y1, z1;
;;;193    			//DEBUG_PRINTF("data[%d]=\n", sensorState.sensorDataIndex);
;;;194    			xl345Read(6,XL345_DATAX0,databuf);
;;;195    			x1 = ( (short) (databuf[0] | databuf[1]<<8));	 // (JWS) old cast was an int
;;;196        		y1 = ( (short) (databuf[2] | databuf[3]<<8));
;;;197        		z1 = ( (short) (databuf[4] | databuf[5]<<8));
;;;198    			//*******if (sensorState.sensorDataIndex <= SENSORBUFFERSIZE) { ////
;;;199    //				sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)] = lastTime + count * (thisTime - lastTime) / (entryCount-1);
;;;200    //				sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)] = count;		// (JWS) remove time from buffer
;;;201    				sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)] = x1;
000068  e59f40b8          LDR      r4,|L3.296|
00006c  e200003f          AND      r0,r0,#0x3f           ;190
000070  e58d000c          STR      r0,[sp,#0xc]
000074  ea000020          B        |L3.252|
                  |L3.120|
000078  e28d2004          ADD      r2,sp,#4              ;194
00007c  e3a01032          MOV      r1,#0x32              ;194
000080  e3a00006          MOV      r0,#6                 ;194
000084  ebfffffe          BL       xl345Read
000088  e5dd0004          LDRB     r0,[sp,#4]            ;195
00008c  e5dd1005          LDRB     r1,[sp,#5]            ;195
000090  e1803401          ORR      r3,r0,r1,LSL #8       ;195
000094  e5dd0006          LDRB     r0,[sp,#6]            ;196
000098  e5dd1007          LDRB     r1,[sp,#7]            ;196
00009c  e1802401          ORR      r2,r0,r1,LSL #8       ;196
0000a0  e5dd0008          LDRB     r0,[sp,#8]            ;197
0000a4  e5dd1009          LDRB     r1,[sp,#9]            ;197
0000a8  e1801401          ORR      r1,r0,r1,LSL #8       ;197
0000ac  e5940000          LDR      r0,[r4,#0]  ; sensorState
0000b0  e0800080          ADD      r0,r0,r0,LSL #1
0000b4  e0840080          ADD      r0,r4,r0,LSL #1
0000b8  e1c030b4          STRH     r3,[r0,#4]
;;;202    				sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)+1] = y1;
0000bc  e5940000          LDR      r0,[r4,#0]  ; sensorState
0000c0  e0800080          ADD      r0,r0,r0,LSL #1
0000c4  e0840080          ADD      r0,r4,r0,LSL #1
0000c8  e1c020b6          STRH     r2,[r0,#6]
;;;203    				sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)+2] = z1;
0000cc  e5940000          LDR      r0,[r4,#0]  ; sensorState
0000d0  e0800080          ADD      r0,r0,r0,LSL #1
0000d4  e0840080          ADD      r0,r4,r0,LSL #1
0000d8  e1c010b8          STRH     r1,[r0,#8]
;;;204    	/*			DEBUG_PRINTF("sensorData[%d] = {t: 0x%X, x: %d, y: %d, z: %d}\n",
;;;205    					sensorState.sensorDataIndex,
;;;206    					sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)],
;;;207    					sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)+1],
;;;208    					sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)+2],
;;;209    					sensorState.sensorData[(sensorState.sensorDataIndex * SENSORDATASIZE)+3]);	 */
;;;210    				sensorState.sensorDataIndex += 1;	  	   
0000dc  e5940000          LDR      r0,[r4,#0]  ; sensorState
0000e0  e2800001          ADD      r0,r0,#1
0000e4  e5840000          STR      r0,[r4,#0]  ; sensorState
;;;211    
;;;212    				if (sensorState.sensorDataIndex >= SENSORBUFFERSIZE) {
0000e8  e5940000          LDR      r0,[r4,#0]  ; sensorState
0000ec  e3500e19          CMP      r0,#0x190
;;;213    					//DEBUG_PRINTF("%d >= %d, resetting to 0\n", sensorState.sensorDataIndex, SENSORBUFFERSIZE);
;;;214    					sensorState.sensorDataIndex = 0;		 ////
0000f0  a5847000          STRGE    r7,[r4,#0]  ; sensorState
0000f4  e2850001          ADD      r0,r5,#1              ;191
0000f8  e20050ff          AND      r5,r0,#0xff           ;191
                  |L3.252|
0000fc  e5dd000c          LDRB     r0,[sp,#0xc]          ;191
000100  e1550000          CMP      r5,r0                 ;191
000104  3affffdb          BCC      |L3.120|
;;;215    				} 
;;;216    			//} else {
;;;217    			//	DEBUG_PRINTF("sensorState.sensorData = %x\n", sensorState.sensorData);
;;;218    			//*******} ////
;;;219    			//DEBUG_PRINTF("entry[%d] = {%d, %d, %d}\n", count, x1, y1, z1);
;;;220    		}
;;;221    		lastTime = thisTime;
000108  e5868008          STR      r8,[r6,#8]  ; lastTime
                  |L3.268|
;;;222    	} else {
;;;223    		DEBUG_PRINTF("Unknown interrupt source: %d\n", interruptSource);
;;;224    	} 
;;;225    //	t2 = T2VAL;
;;;226    
;;;227    
;;;228    //	T2CON = 0x000007c0;
;;;229    }
00010c  e28dd014          ADD      sp,sp,#0x14
000110  e8bd51ff          POP      {r0-r8,r12,lr}
000114  e25ef004          SUBS     pc,lr,#4
                  |L3.280|
000118  e28f000c          ADR      r0,|L3.300|
00011c  ebfffffe          BL       debug_printf
000120  eafffff9          B        |L3.268|
;;;230    
                          ENDP

                  |L3.292|
                          DCD      ||.data||
                  |L3.296|
                          DCD      ||.bss||
                  |L3.300|
00012c  556e6b6e6f776e20696e7465727275707420736f757263653a2025640a00        DCB      "Unknown interrupt source: %d\n",0
00014a  00                DCB      0
00014b  00                DCB      0

                          AREA ||i.InitFs||, CODE, READONLY, ALIGN=2

                  InitFs PROC
;;;514    
;;;515    int InitFs(FilesystemState *fileState) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e24dd070          SUB      sp,sp,#0x70
000008  e1a04000          MOV      r4,r0
;;;516    	char logDirectory[100] = {0};
00000c  e3a01064          MOV      r1,#0x64
000010  e28d000c          ADD      r0,sp,#0xc
000014  ebfffffe          BL       __aeabi_memclr4
;;;517    	int logCount = 0;
000018  e3a05000          MOV      r5,#0
;;;518    	int result = 0;
;;;519    
;;;520    	// log directory
;;;521    	snprintf(logDirectory, 
00001c  e28f3f55          ADR      r3,|L4.376|
000020  e28f2f56          ADR      r2,|L4.384|
000024  e3a01063          MOV      r1,#0x63
000028  e28d000c          ADD      r0,sp,#0xc
00002c  ebfffffe          BL       __2snprintf
;;;522    		99, 
;;;523    		"%s", 
;;;524    		DEFAULT_LOG_DIRECTORY);
;;;525    	 
;;;526    	// log filename
;;;527    	snprintf(fileState->logFileName, 
000030  e28f2f53          ADR      r2,|L4.388|
000034  e88d0024          STM      sp,{r2,r5}
000038  e2840b03          ADD      r0,r4,#0xc00
00003c  e2800f6d          ADD      r0,r0,#0x1b4
000040  e28f3e13          ADR      r3,|L4.376|
000044  e28f2d05          ADR      r2,|L4.396|
000048  e3a01063          MOV      r1,#0x63
00004c  e1a05000          MOV      r5,r0
000050  ebfffffe          BL       __2snprintf
;;;528    		99, 
;;;529    		"%s/%s%04d.txt", 
;;;530    		DEFAULT_LOG_DIRECTORY,
;;;531    		DEFAULT_LOG_FILENAME,
;;;532    		logCount);
;;;533    
;;;534    	DEBUG_PRINTF("%s:%d InitFs(): going to log to %s\n", __FILE__, __LINE__, fileState->logFileName);
000054  e59f2140          LDR      r2,|L4.412|
000058  e1a03005          MOV      r3,r5                 ;527
00005c  e28f1f4f          ADR      r1,|L4.416|
000060  e28f0f52          ADR      r0,|L4.432|
000064  ebfffffe          BL       debug_printf
;;;535    	
;;;536    	// initialize filesystem
;;;537    	result = efs_init(&(fileState->efs), 0);
000068  e3a01000          MOV      r1,#0
00006c  e1a00004          MOV      r0,r4
000070  ebfffffe          BL       efs_init
;;;538    	if (result) {
000074  e3500000          CMP      r0,#0
;;;539    		DEBUG_PRINTF("%s:%d InitFs(): failed on efs_init() = %d\n", __FILE__, __LINE__, result);
000078  159f2154          LDRNE    r2,|L4.468|
00007c  11a03000          MOVNE    r3,r0
000080  128f1f46          ADRNE    r1,|L4.416|
000084  128f0f53          ADRNE    r0,|L4.472|
;;;540    		return false;
000088  1a000036          BNE      |L4.360|
;;;541    	}
;;;542    	// make the directory if needed
;;;543    	result = mkdir(&(fileState->efs.myFs), logDirectory);
00008c  e2840b03          ADD      r0,r4,#0xc00
000090  e2800f49          ADD      r0,r0,#0x124
000094  e28d100c          ADD      r1,sp,#0xc
000098  e1a06000          MOV      r6,r0
00009c  ebfffffe          BL       mkdir
;;;544    	DEBUG_PRINTF("%s:%d InitFs(): result of mkdir(%s) = %d\n", __FILE__, __LINE__, logDirectory, result);
0000a0  e58d0000          STR      r0,[sp,#0]
0000a4  e28d300c          ADD      r3,sp,#0xc
0000a8  e3a02e22          MOV      r2,#0x220
0000ac  e28f10ec          ADR      r1,|L4.416|
0000b0  e28f0f53          ADR      r0,|L4.516|
0000b4  ebfffffe          BL       debug_printf
;;;545    	// open the log file for writing
;;;546    	result = file_fopen(&(fileState->logFile), &(fileState->efs.myFs), fileState->logFileName, 'a');
0000b8  e2840b03          ADD      r0,r4,#0xc00
0000bc  e2800f59          ADD      r0,r0,#0x164
0000c0  e3a03061          MOV      r3,#0x61
0000c4  e1a02005          MOV      r2,r5
0000c8  e1a01006          MOV      r1,r6
0000cc  e1a04000          MOV      r4,r0
0000d0  ebfffffe          BL       file_fopen
;;;547    	if (result) {
0000d4  e3500000          CMP      r0,#0
;;;548    		DEBUG_PRINTF("%s:%d InitFs(): failed on file_fopen(\"%s\") = %d\n", __FILE__, __LINE__, fileState->logFileName, result);
0000d8  158d0000          STRNE    r0,[sp,#0]
0000dc  11a03005          MOVNE    r3,r5
0000e0  13a02f89          MOVNE    r2,#0x224
0000e4  128f10b4          ADRNE    r1,|L4.416|
0000e8  128f0d05          ADRNE    r0,|L4.560|
;;;549    		return false;
0000ec  1a00001d          BNE      |L4.360|
;;;550    	}
;;;551    
;;;552    //	result = data_log(fileState, "t,x,y,z\n");
;;;553    
;;;554    	result = file_write(&(fileState->logFile), strlen("t,x,y,z\n"), "t,x,y,z\n");
0000f0  e28f2f5b          ADR      r2,|L4.612|
0000f4  e3a01008          MOV      r1,#8
0000f8  e1a00004          MOV      r0,r4
0000fc  ebfffffe          BL       file_write
;;;555    
;;;556    	if (!result) {
000100  e3500000          CMP      r0,#0
;;;557    		DEBUG_PRINTF("%s:%d InitFs(): failed on data_log(\"%s\") = %d\n", __FILE__, __LINE__, fileState->logFileName, result);
000104  059f2164          LDREQ    r2,|L4.624|
000108  058d0000          STREQ    r0,[sp,#0]
00010c  01a03005          MOVEQ    r3,r5
000110  028f1088          ADREQ    r1,|L4.416|
000114  028f0f56          ADREQ    r0,|L4.628|
;;;558    		return false;
000118  0a000012          BEQ      |L4.360|
;;;559    	}
;;;560    	DEBUG_PRINTF(">>> wrote header to log file\n");
00011c  e28f0d06          ADR      r0,|L4.676|
000120  ebfffffe          BL       debug_printf
000124  e1a00004          MOV      r0,r4
;;;561    	
;;;562    	result = file_fclose(&(fileState->logFile));
000128  ebfffffe          BL       file_fclose
;;;563    	if (result) {
00012c  e3500000          CMP      r0,#0
;;;564    		DEBUG_PRINTF("%s:%d InitFs(): failed on file_fclose(\"%s\") = %d\n", __FILE__, __LINE__, fileState->logFileName, result);
000130  158d0000          STRNE    r0,[sp,#0]
000134  11a03005          MOVNE    r3,r5
000138  13a02f8d          MOVNE    r2,#0x234
00013c  128f105c          ADRNE    r1,|L4.416|
000140  128f0f5f          ADRNE    r0,|L4.708|
;;;565    		return false;
000144  1a000007          BNE      |L4.360|
000148  e1a00006          MOV      r0,r6
;;;566    	}
;;;567    
;;;568    	result = fs_umount(&(fileState->efs.myFs));
00014c  ebfffffe          BL       fs_umount
;;;569    	if (result) {
000150  e3500000          CMP      r0,#0
000154  0a000076          BEQ      |L4.820|
;;;570    		DEBUG_PRINTF("%s:%d init_file_system(): failed on fs_umount() = %d\n", __FILE__, __LINE__, result);
000158  e1a03000          MOV      r3,r0
00015c  e59f2194          LDR      r2,|L4.760|
000160  e28f1038          ADR      r1,|L4.416|
000164  e28f0e19          ADR      r0,|L4.764|
                  |L4.360|
000168  ebfffffe          BL       debug_printf
;;;571    		return false;
00016c  e3a00000          MOV      r0,#0
                  |L4.368|
000170  e28dd070          ADD      sp,sp,#0x70
;;;572    	}
;;;573    	
;;;574    	DEBUG_PRINTF("%s:%d InitFs() done\n", __FILE__, __LINE__);
;;;575    	return true;
;;;576    }
000174  e8bd8070          POP      {r4-r6,pc}
                  |L4.376|
000178  786c33343500        DCB      "xl345",0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L4.384|
000180  257300            DCB      "%s",0
000183  00                DCB      0
                  |L4.388|
000184  6461746100        DCB      "data",0
000189  00                DCB      0
00018a  00                DCB      0
00018b  00                DCB      0
                  |L4.396|
00018c  25732f2573253034642e74787400        DCB      "%s/%s%04d.txt",0
00019a  00                DCB      0
00019b  00                DCB      0
                  |L4.412|
                          DCD      0x00000216
                  |L4.416|
0001a0  646174616c6f67676572352e6300        DCB      "datalogger5.c",0
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L4.432|
0001b0  25733a256420496e6974467328293a20676f696e6720746f206c6f6720746f2025730a00        DCB      "%s:%d InitFs(): going to log to %s\n",0
                  |L4.468|
                          DCD      0x0000021b
                  |L4.472|
0001d8  25733a256420496e6974467328293a206661696c6564206f6e206566735f696e69742829203d2025640a00        DCB      "%s:%d InitFs(): failed on efs_init() = %d\n",0
000203  00                DCB      0
                  |L4.516|
000204  25733a256420496e6974467328293a20726573756c74206f66206d6b64697228257329203d2025640a00        DCB      "%s:%d InitFs(): result of mkdir(%s) = %d\n",0
00022e  00                DCB      0
00022f  00                DCB      0
                  |L4.560|
000230  25733a256420496e6974467328293a206661696c6564206f6e2066696c655f666f70656e282225732229203d2025640a00        DCB      "%s:%d InitFs(): failed on file_fopen(""%s"") = %d\n",0
000261  00                DCB      0
000262  00                DCB      0
000263  00                DCB      0
                  |L4.612|
000264  742c782c792c7a0a00        DCB      "t,x,y,z\n",0
00026d  00                DCB      0
00026e  00                DCB      0
00026f  00                DCB      0
                  |L4.624|
                          DCD      0x0000022d
                  |L4.628|
000274  25733a256420496e6974467328293a206661696c6564206f6e20646174615f6c6f67282225732229203d2025640a00        DCB      "%s:%d InitFs(): failed on data_log(""%s"") = %d\n",0
0002a3  00                DCB      0
                  |L4.676|
0002a4  3e3e3e2077726f74652068656164657220746f206c6f672066696c650a00        DCB      ">>> wrote header to log file\n",0
0002c2  00                DCB      0
0002c3  00                DCB      0
                  |L4.708|
0002c4  25733a256420496e6974467328293a206661696c6564206f6e2066696c655f66636c6f7365282225732229203d2025640a00        DCB      "%s:%d InitFs(): failed on file_fclose(""%s"") = %d\n",0
0002f6  00                DCB      0
0002f7  00                DCB      0
                  |L4.760|
                          DCD      0x0000023a
                  |L4.764|
0002fc  25733a256420696e69745f66696c655f73797374656d28293a206661696c6564206f6e2066735f756d6f756e742829203d2025640a00        DCB      "%s:%d init_file_system(): failed on fs_umount() = %d\n",0
000332  00                DCB      0
000333  00                DCB      0
                  |L4.820|
000334  e59f2010          LDR      r2,|L4.844|
000338  e24f1e1a          ADR      r1,|L4.416|
00033c  e28f000c          ADR      r0,|L4.848|
000340  ebfffffe          BL       debug_printf
000344  e3a00001          MOV      r0,#1                 ;575
000348  eaffff88          B        |L4.368|
;;;577    
                          ENDP

                  |L4.844|
                          DCD      0x0000023e
                  |L4.848|
000350  25733a256420496e69744673282920646f6e650a00        DCB      "%s:%d InitFs() done\n",0
000365  00                DCB      0
000366  00                DCB      0
000367  00                DCB      0

                          AREA ||i.Initialize||, CODE, READONLY, ALIGN=2

                  Initialize PROC
;;;275    
;;;276    int Initialize() {
000000  e92d4070          PUSH     {r4-r6,lr}
;;;277    
;;;278    
;;;279    //	IRQ = myisr;	// Specify Interrupt Service Routine
;;;280    //	SWI = myswi;
;;;281    //	FIQ = myfiq;
;;;282    //	UNDEF = myundef;
;;;283    //	DABORT = mydabort;
;;;284    //	PABORT = mypabort;
;;;285    	
;;;286    	GP3CON = GP3CONGPIOVAL; // configure GPIO pins
000004  e3a05000          MOV      r5,#0
000008  e5055bf4          STR      r5,[r5,#-0xbf4]
;;;287    	GP3PAR = ALLPUPOFF;  // turn off pull ups
00000c  e59f0144          LDR      r0,|L5.344|
000010  e5050ba4          STR      r0,[r5,#-0xba4]
;;;288    	GP3DAT = GP3OFF;     // set LED pins to output and PWM to GPIOOFF
000014  e3a0043f          MOV      r0,#0x3f000000
000018  e5050bb0          STR      r0,[r5,#-0xbb0]
;;;289    	GP4CON = GP4CONVAL;
00001c  e5055bf0          STR      r5,[r5,#-0xbf0]
;;;290    	//  GP4DAT = GP4OUT;
;;;291    	GP4DAT = 0xFF000000;
000020  e3a004ff          MOV      r0,#0xff000000
000024  e5050ba0          STR      r0,[r5,#-0xba0]
;;;292    	
;;;293    	i2cinit(); // set up the I2C bus
000028  ebfffffe          BL       i2cinit
;;;294    
;;;295    	UART_Config();
00002c  ebfffffe          BL       UART_Config
;;;296    
;;;297     	/* soft reset for safety */
;;;298      	xbuffer[0] = XL345_RESERVED1; /* register address */
000030  e59f4124          LDR      r4,|L5.348|
000034  e3a00001          MOV      r0,#1
000038  e5c40000          STRB     r0,[r4,#0]  ; xbuffer
;;;299      	xbuffer[1] = XL345_SOFT_RESET;
00003c  e3a00052          MOV      r0,#0x52
000040  e5c40001          STRB     r0,[r4,#1]  ; xbuffer
;;;300      	xl345Write(2,xbuffer);
000044  e2841000          ADD      r1,r4,#0
000048  e3a00002          MOV      r0,#2
00004c  ebfffffe          BL       xl345Write
;;;301    
;;;302      	delay(2000);  // allow delay after a soft reset
000050  e3a00e7d          MOV      r0,#0x7d0
                  |L5.84|
000054  e2500001          SUBS     r0,r0,#1
000058  5afffffd          BPL      |L5.84|
;;;303    
;;;304    	/*--------------------------------------------------
;;;305        TAP Configuration
;;;306        --------------------------------------------------*/
;;;307      /* set up a buffer with all the initialization for tap */
;;;308      xbuffer[0] = XL345_THRESH_TAP; /* register address */
00005c  e3a0001d          MOV      r0,#0x1d
000060  e5c40000          STRB     r0,[r4,#0]  ; xbuffer
;;;309      xbuffer[1] = 80; /* THRESH_TAP = 5 Gee (1 lsb = 1/16 gee) */	
000064  e3a06050          MOV      r6,#0x50
;;;310      xl345Write(2,xbuffer);
000068  e59f10ec          LDR      r1,|L5.348|
00006c  e3a00002          MOV      r0,#2
000070  e5c46001          STRB     r6,[r4,#1]            ;309  ; xbuffer
000074  ebfffffe          BL       xl345Write
;;;311    
;;;312      xbuffer[0] = XL345_DUR; /* register address */
000078  e3a00021          MOV      r0,#0x21
00007c  e5c40000          STRB     r0,[r4,#0]  ; xbuffer
;;;313      xbuffer[1] = 13; /* DUR = 8ms 0.6125ms/lsb */
000080  e3a0000d          MOV      r0,#0xd
000084  e5c40001          STRB     r0,[r4,#1]  ; xbuffer
;;;314      xbuffer[2] = 80; /* LATENT = 100 ms 1.25ms/lsb */
;;;315      xbuffer[3] = 240;/* WINDOW 300ms 1.25ms/lsb */
000088  e3a000f0          MOV      r0,#0xf0
00008c  e5c46002          STRB     r6,[r4,#2]            ;314  ; xbuffer
000090  e5c40003          STRB     r0,[r4,#3]  ; xbuffer
;;;316      xl345Write(4,xbuffer);
000094  e59f10c0          LDR      r1,|L5.348|
000098  e3a00004          MOV      r0,#4
00009c  ebfffffe          BL       xl345Write
;;;317    
;;;318      xbuffer[0] = XL345_TAP_AXES; /* register address */
0000a0  e3a0002a          MOV      r0,#0x2a
0000a4  e5c40000          STRB     r0,[r4,#0]  ; xbuffer
;;;319      xbuffer[1] = XL345_TAP_Z_ENABLE | XL345_TAP_Y_ENABLE 
0000a8  e3a00007          MOV      r0,#7
0000ac  e5c40001          STRB     r0,[r4,#1]  ; xbuffer
;;;320        | XL345_TAP_X_ENABLE /*|  XL345_TAP_SUPPRESS*/;
;;;321      xl345Write(2,xbuffer);
0000b0  e59f10a4          LDR      r1,|L5.348|
0000b4  e3a00002          MOV      r0,#2
0000b8  ebfffffe          BL       xl345Write
;;;322    
;;;323      /*--------------------------------------------------
;;;324        activity - inactivity 
;;;325        --------------------------------------------------*/
;;;326      /* set up a buffer with all the initialization for activity and inactivity */
;;;327      xbuffer[0] = XL345_THRESH_ACT; /* register address */
0000bc  e3a00024          MOV      r0,#0x24
0000c0  e5c40000          STRB     r0,[r4,#0]  ; xbuffer
;;;328      xbuffer[1] = 80; /* THRESH_ACT = 80/16 = 5 Gee (1 lsb = 1/16 gee) */
;;;329      xbuffer[2] = 4; /* THRESH_INACT = 14/16 .25 Gee (1 lsb = 1/16 gee) */
0000c4  e3a00004          MOV      r0,#4
0000c8  e5c46001          STRB     r6,[r4,#1]            ;328  ; xbuffer
0000cc  e5c40002          STRB     r0,[r4,#2]  ; xbuffer
;;;330      xbuffer[3] = 5;/* TIME_INACT - 5 seconds 2 minutes*/
0000d0  e3a00005          MOV      r0,#5
0000d4  e5c40003          STRB     r0,[r4,#3]  ; xbuffer
;;;331      xbuffer[4] = XL345_ACT_DC | XL345_ACT_X_ENABLE | XL345_ACT_Y_ENABLE | XL345_ACT_Z_ENABLE
0000d8  e3a0007f          MOV      r0,#0x7f
0000dc  e5c40004          STRB     r0,[r4,#4]  ; xbuffer
;;;332        | XL345_INACT_AC | XL345_INACT_X_ENABLE 
;;;333        | XL345_INACT_Y_ENABLE | XL345_INACT_Z_ENABLE;		  /* ACT_INACT_CTL */
;;;334      xl345Write(5,xbuffer);
0000e0  e59f1074          LDR      r1,|L5.348|
0000e4  e3a00005          MOV      r0,#5
0000e8  ebfffffe          BL       xl345Write
;;;335    
;;;336    
;;;337      /*--------------------------------------------------
;;;338        Power, bandwidth-rate, interupt enabling
;;;339        --------------------------------------------------*/
;;;340    
;;;341      /* set up a buffer with all the initization for power*/
;;;342      xbuffer[0] = XL345_BW_RATE;    /* register address */
0000ec  e3a0002c          MOV      r0,#0x2c
0000f0  e5c40000          STRB     r0,[r4,#0]  ; xbuffer
;;;343      xbuffer[1] = XL345_RATE_400 | XL345_LOW_NOISE;	  /* BW rate */
0000f4  e3a0000c          MOV      r0,#0xc
0000f8  e5c40001          STRB     r0,[r4,#1]  ; xbuffer
;;;344      xbuffer[2] = XL345_WAKEUP_8HZ | XL345_MEASURE;	  /* POWER_CTL */
0000fc  e3a00008          MOV      r0,#8
000100  e5c40002          STRB     r0,[r4,#2]  ; xbuffer
;;;345      xl345Write(3,xbuffer);
000104  e59f1050          LDR      r1,|L5.348|
000108  e3a00003          MOV      r0,#3
00010c  ebfffffe          BL       xl345Write
;;;346    	
;;;347    	// set the FIFO control
;;;348    	xbuffer[0] = XL345_FIFO_CTL;
000110  e3a00038          MOV      r0,#0x38
000114  e5c40000          STRB     r0,[r4,#0]  ; xbuffer
;;;349    	xbuffer[1] = XL345_FIFO_MODE_FIFO | 0 | 31;	// set FIFO mode, link to INT1, number of samples
000118  e3a0005f          MOV      r0,#0x5f
00011c  e5c40001          STRB     r0,[r4,#1]  ; xbuffer
;;;350    //	buffer[1] = XL345_FIFO_MODE_STREAM | 0 | 31;
;;;351    	xl345Write(2, xbuffer);
000120  e59f1034          LDR      r1,|L5.348|
000124  e3a00002          MOV      r0,#2
000128  ebfffffe          BL       xl345Write
;;;352    
;;;353    	// turn on the watermark interrupt and set the watermark interrupt to int1
;;;354    	xbuffer[0] = XL345_INT_ENABLE;
00012c  e3a0002e          MOV      r0,#0x2e
000130  e5c40000          STRB     r0,[r4,#0]  ; xbuffer
;;;355    	xbuffer[1] = XL345_WATERMARK | XL345_OVERRUN; // enable D1
000134  e3a00003          MOV      r0,#3
000138  e5c40001          STRB     r0,[r4,#1]  ; xbuffer
;;;356    	xbuffer[2] = 0; // send all interrupts to INT1
;;;357    	xl345Write(3, xbuffer);
00013c  e59f1018          LDR      r1,|L5.348|
000140  e5c45002          STRB     r5,[r4,#2]            ;356  ; xbuffer
000144  ebfffffe          BL       xl345Write
;;;358    						 
;;;359    	GP4CLR = 0xff<<16;
000148  e3a008ff          MOV      r0,#0xff0000
00014c  e5050b98          STR      r0,[r5,#-0xb98]
;;;360    
;;;361    	// Setup timer 2 to use for timing
;;;362    // 	T2LD = 0;			  // Timer 2 load register = 0
;;;363    //	T2CON = (1<<6) | (1<<7) | (1<<8) | (1<<10) | 0x4; 	// 32-bits Timer 2 control register
;;;364    														//	Enabled, internal osc., periodic mode, count up, Binary
;;;365    //	T2CON = 0x000007c0; // Enabled, core clock, count up, periodic (resets to zero at max), source clock/1
;;;366    
;;;367    //	T2CON = 0x000005cf; // Enabled, 32.768 osc, count up, periodic (resets to zero at max), clock/32768
;;;368    
;;;369    	return true;
000150  e3a00001          MOV      r0,#1
;;;370    }
000154  e8bd8070          POP      {r4-r6,pc}
;;;371    
                          ENDP

                  |L5.344|
                          DCD      0x11111111
                  |L5.348|
                          DCD      ||.data||+0xc

                          AREA ||i.PAbt_Handler||, CODE, READONLY, ALIGN=2

                  PAbt_Handler PROC
;;;262    
;;;263    void PAbt_Handler() __irq 
000000  e92d500f          PUSH     {r0-r3,r12,lr}
;;;264    {
;;;265    	DEBUG_PRINTF("MYPABORT\n");
000004  e28f0014          ADR      r0,|L6.32|
000008  ebfffffe          BL       debug_printf
;;;266    	greenLight(false);
00000c  e3a00000          MOV      r0,#0
000010  ebfffffe          BL       greenLight
;;;267    	redLight(true);
000014  e3a00001          MOV      r0,#1
000018  ebfffffe          BL       redLight
                  |L6.28|
;;;268    	while (true);
00001c  eafffffe          B        |L6.28|
;;;269    }
;;;270    
                          ENDP

                  |L6.32|
000020  4d595041424f52540a00        DCB      "MYPABORT\n",0
00002a  00                DCB      0
00002b  00                DCB      0

                          AREA ||i.SWI_Handler||, CODE, READONLY, ALIGN=2

                  SWI_Handler PROC
;;;230    
;;;231    void SWI_Handler() __irq
000000  e92d500f          PUSH     {r0-r3,r12,lr}
;;;232    {
;;;233    	DEBUG_PRINTF("MYSWI\n");
000004  e28f0014          ADR      r0,|L7.32|
000008  ebfffffe          BL       debug_printf
;;;234    	greenLight(false);
00000c  e3a00000          MOV      r0,#0
000010  ebfffffe          BL       greenLight
;;;235    	redLight(true);
000014  e3a00001          MOV      r0,#1
000018  ebfffffe          BL       redLight
                  |L7.28|
;;;236    	while (true);
00001c  eafffffe          B        |L7.28|
;;;237    }
;;;238    
                          ENDP

                  |L7.32|
000020  4d595357490a00        DCB      "MYSWI\n",0
000027  00                DCB      0

                          AREA ||i.SensorLoop||, CODE, READONLY, ALIGN=2

                  SensorLoop PROC
;;;577    
;;;578    int SensorLoop(FilesystemState *fileState) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  e1a0a000          MOV      r10,r0
;;;579    
;;;580    //	unsigned char buffer[8];
;;;581    	int half = 0;
000008  e3a04000          MOV      r4,#0
;;;582    //	int result, tmr2 = 0;
;;;583    	int midway = SENSORBUFFERSIZE / 2;
00000c  e3a050c8          MOV      r5,#0xc8
;;;584    	DEBUG_PRINTF(">>> Starting Sensor loop\n");
000010  e28f00ac          ADR      r0,|L8.196|
000014  ebfffffe          BL       debug_printf
;;;585    	sensorState.sensorDataIndex = 0;
000018  e59f70c0          LDR      r7,|L8.224|
00001c  e3a08000          MOV      r8,#0
000020  e5878000          STR      r8,[r7,#0]  ; sensorState
;;;586    
;;;587    
;;;588    
;;;589       	IRQEN = (1<<15);			 // Enable Interrupt here for the ADXL = IRQ0 enabled
000024  e3a00902          MOV      r0,#0x8000
000028  e2406906          SUB      r6,r0,#0x18000
00002c  e5860008          STR      r0,[r6,#8]
;;;590    
;;;591    	greenLight(true);	 	// Turn on green LED
000030  e3a00001          MOV      r0,#1
000034  ebfffffe          BL       greenLight
;;;592    	
;;;593    	lastTime = T2VAL;
000038  e5960344          LDR      r0,[r6,#0x344]
00003c  e59f90a0          LDR      r9,|L8.228|
;;;594    
;;;595    #ifdef recording	
;;;596    		//DEBUG_PRINTF("L1\n");
;;;597    	result = efs_init(&(fileState->efs), 0);
;;;598    
;;;599    //	t1 = T2VAL;
;;;600    	//DEBUG_PRINTF("L2\n");
;;;601    	if (result) {
;;;602    		DEBUG_PRINTF("%s:%d batch_log(): failed on efs_init() = %d\n", __FILE__, __LINE__, result);
;;;603    		return false;
;;;604    	}
;;;605    	//DEBUG_PRINTF("L3 %s\n", fileState->logFileName);
;;;606    
;;;607    	result = file_fopen(&(fileState->logFile), &(fileState->efs.myFs), fileState->logFileName, 'a');
;;;608    
;;;609    //	t2 = T2VAL;
;;;610    	//DEBUG_PRINTF("L4\n");
;;;611    	if (result) {
;;;612    		DEBUG_PRINTF("%s:%d batch_log(): failed on file_fopen(\"%s\") = %d\n", __FILE__, __LINE__, fileState->logFileName, result);
;;;613    		return false;
;;;614    	}
;;;615    	//DEBUG_PRINTF("L5\n"); 
;;;616    #endif
;;;617    
;;;618    	
;;;619    	T2LD = 0;			  // Timer 2 load register = 0
000040  e5890008          STR      r0,[r9,#8]  ; lastTime
000044  e5868340          STR      r8,[r6,#0x340]
;;;620    	T2CON = 0;
000048  e5868348          STR      r8,[r6,#0x348]
;;;621     	T2CON = 0x000005cf; // Enabled, 32.768 osc, count up, periodic (resets to zero at max), clock/32768
00004c  e59f0094          LDR      r0,|L8.232|
000050  e5860348          STR      r0,[r6,#0x348]
                  |L8.84|
;;;622    
;;;623    #ifdef one_sec_timer1
;;;624    	T1LD = 0;
;;;625    	T1CON = 0;
;;;626    	T1CON = 0x000211c0;  // Enable T1, internal clock, count up, periodic, clock/1, event 1 = timer 1	
;;;627    #endif
;;;628    
;;;629    	while (true) {	   // Ping pong buffer
;;;630    		//DEBUG_PRINTF("--- Loop iteration %08x\n", T2VAL);
;;;631    		// We stay in this loop indefinitely
;;;632    //		IRQEN = (1<<15);
;;;633    
;;;634    #ifdef one_sec_timer2
;;;635    
;;;636    	if (T2VAL == 7) {
000054  e5960344          LDR      r0,[r6,#0x344]
000058  e3500007          CMP      r0,#7
00005c  1a000000          BNE      |L8.100|
                  |L8.96|
;;;637    		while (1);			// set breakpoint here to halt once 1 sec of data is written out
000060  eafffffe          B        |L8.96|
                  |L8.100|
;;;638    	}
;;;639    
;;;640    #endif
;;;641    
;;;642    #ifdef cyc_cntr_timer1
;;;643    
;;;644    	if (T1VAL >= 208896000) {		
;;;645    		while (1);			// only capture 5 seconds worth of data with timer 1  
;;;646    	}						// 208896000 = 5 sec = 5 * 41779200 Mhz
;;;647    
;;;648    #endif
;;;649    
;;;650    	
;;;651    		if ((half == 0) && (sensorState.sensorDataIndex >= midway)) {
000064  e3540000          CMP      r4,#0
000068  1a000009          BNE      |L8.148|
00006c  e5970000          LDR      r0,[r7,#0]  ; sensorState
000070  e1500005          CMP      r0,r5
000074  bafffff6          BLT      |L8.84|
;;;652    			// sensorDataIndix is currently pointing to data captured by ADXL **while** we write out the other half
;;;653    			// You write out the half buffer ONLY ONCE
;;;654    			//DEBUG_PRINTF("Half is %d, and index is %d which is >= than %d\n", half, sensorState.sensorDataIndex, midway);
;;;655    //			DEBUG_PRINTF("count at start upper %08x\n", T2VAL);
;;;656    
;;;657    			batch_log(fileState, 0, midway);	 // where we write out lower half while the upper is filled
000078  e1a02005          MOV      r2,r5
00007c  e3a01000          MOV      r1,#0
000080  e1a0000a          MOV      r0,r10
000084  ebfffffe          BL       batch_log
;;;658    //			IRQEN = 0; 				// Turn off interrupts
;;;659    			num_of_int = 0;
;;;660    			half = 1;
000088  e3a04001          MOV      r4,#1
00008c  e5898004          STR      r8,[r9,#4]  ; num_of_int
000090  eaffffef          B        |L8.84|
                  |L8.148|
;;;661    //			DEBUG_PRINTF("count at end upper %08x\n", T2VAL);
;;;662    		} else if ((half == 1) && (sensorState.sensorDataIndex < midway)) {
000094  e3540001          CMP      r4,#1
000098  1affffed          BNE      |L8.84|
00009c  e5970000          LDR      r0,[r7,#0]  ; sensorState
0000a0  e1500005          CMP      r0,r5
0000a4  aaffffea          BGE      |L8.84|
;;;663    			// sensorDataIndix is currently pointing to data captured by ADXL **while** we write out the other half
;;;664    			//DEBUG_PRINTF("Half is %d, and index is %d which is < than %d\n", half, sensorState.sensorDataIndex, midway);
;;;665    //			DEBUG_PRINTF("count at start lower %08x\n", T2VAL);
;;;666    			batch_log(fileState, midway, SENSORBUFFERSIZE);	  // where we write out the upper half of the file while the lower is filled
0000a8  e3a02e19          MOV      r2,#0x190
0000ac  e1a01005          MOV      r1,r5
0000b0  e1a0000a          MOV      r0,r10
0000b4  ebfffffe          BL       batch_log
;;;667    //			IRQEN = 0;
;;;668    			num_of_int = 0;
;;;669    			half = 0;
0000b8  e3a04000          MOV      r4,#0
0000bc  e5898004          STR      r8,[r9,#4]  ; num_of_int
0000c0  eaffffe3          B        |L8.84|
;;;670    //			DEBUG_PRINTF("count at end lower %08x\n", T2VAL);
;;;671    		}
;;;672    		/*if (sensorState.sensorDataIndex >= SENSORBUFFERSIZE) {
;;;673    			IRQCLR = (1<<15);
;;;674    			batch_log(fileState, 0, SENSORBUFFERSIZE);
;;;675    			while (true); 
;;;676    		}*/
;;;677    	}		// while loop
;;;678    return true;
;;;679    }
;;;680    
                          ENDP

                  |L8.196|
0000c4  3e3e3e205374617274696e672053656e736f72206c6f6f700a00        DCB      ">>> Starting Sensor loop\n",0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L8.224|
                          DCD      ||.bss||
                  |L8.228|
                          DCD      ||.data||
                  |L8.232|
                          DCD      0x000005cf

                          AREA ||i.Undef_Handler||, CODE, READONLY, ALIGN=2

                  Undef_Handler PROC
;;;246    
;;;247    void Undef_Handler() __irq
000000  e92d500f          PUSH     {r0-r3,r12,lr}
;;;248    {
;;;249    	DEBUG_PRINTF("MYUNDEF\n");
000004  e28f0014          ADR      r0,|L9.32|
000008  ebfffffe          BL       debug_printf
;;;250    	greenLight(false);
00000c  e3a00000          MOV      r0,#0
000010  ebfffffe          BL       greenLight
;;;251    	redLight(true);
000014  e3a00001          MOV      r0,#1
000018  ebfffffe          BL       redLight
                  |L9.28|
;;;252    	while (true);
00001c  eafffffe          B        |L9.28|
;;;253    }
;;;254    
                          ENDP

                  |L9.32|
000020  4d59554e4445460a00        DCB      "MYUNDEF\n",0
000029  00                DCB      0
00002a  00                DCB      0
00002b  00                DCB      0

                          AREA ||i.batch_log||, CODE, READONLY, ALIGN=2

                  batch_log PROC
;;;378    
;;;379    int batch_log(FilesystemState *fileState, int start, int end) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  e24dd040          SUB      sp,sp,#0x40
000008  e1a08000          MOV      r8,r0
00000c  e1a04001          MOV      r4,r1
000010  e1a05002          MOV      r5,r2
;;;380    	
;;;381    	//DEBUG_PRINTF("Logging from %d to %d\n", start, end);
;;;382    	char line[50] = {0};
000014  e3a01034          MOV      r1,#0x34
000018  e28d000c          ADD      r0,sp,#0xc
00001c  ebfffffe          BL       __aeabi_memclr4
;;;383    	int i = 0;
;;;384    //	int t1, t2, t3, t4, t5 = 0;
;;;385    	int result = 0;
;;;386    
;;;387    //	T2LD = 0x0;
;;;388    //	T2CON = 0x000007c0; // Enabled, core clock, count up, periodic (resets to zero at max), source clock/1
;;;389    
;;;390    #ifndef recording
;;;391    	//DEBUG_PRINTF("L1\n");
;;;392    	result = efs_init(&(fileState->efs), 0);
000020  e3a01000          MOV      r1,#0
000024  e1a00008          MOV      r0,r8
000028  ebfffffe          BL       efs_init
;;;393    
;;;394    //	t1 = T2VAL;
;;;395    	//DEBUG_PRINTF("L2\n");
;;;396    	if (result) {
00002c  e3500000          CMP      r0,#0
;;;397    		DEBUG_PRINTF("%s:%d batch_log(): failed on efs_init() = %d\n", __FILE__, __LINE__, result);
000030  159f2110          LDRNE    r2,|L10.328|
000034  11a03000          MOVNE    r3,r0
000038  128f1f43          ADRNE    r1,|L10.332|
00003c  128f0f46          ADRNE    r0,|L10.348|
;;;398    		return false;
000040  1a00003c          BNE      |L10.312|
;;;399    	}
;;;400    	//DEBUG_PRINTF("L3 %s\n", fileState->logFileName);
;;;401    
;;;402    	result = file_fopen(&(fileState->logFile), &(fileState->efs.myFs), fileState->logFileName, 'a');
000044  e2882b03          ADD      r2,r8,#0xc00
000048  e2881b03          ADD      r1,r8,#0xc00
00004c  e2880b03          ADD      r0,r8,#0xc00
000050  e2822f6d          ADD      r2,r2,#0x1b4
000054  e2811f49          ADD      r1,r1,#0x124
000058  e2800f59          ADD      r0,r0,#0x164
00005c  e3a03061          MOV      r3,#0x61
000060  e1a06002          MOV      r6,r2
000064  e1a07001          MOV      r7,r1
000068  e1a08000          MOV      r8,r0
00006c  ebfffffe          BL       file_fopen
;;;403    
;;;404    //	t2 = T2VAL;
;;;405    	//DEBUG_PRINTF("L4\n");
;;;406    	if (result) {
000070  e3500000          CMP      r0,#0
;;;407    		DEBUG_PRINTF("%s:%d batch_log(): failed on file_fopen(\"%s\") = %d\n", __FILE__, __LINE__, fileState->logFileName, result);
000074  159f2110          LDRNE    r2,|L10.396|
000078  158d0000          STRNE    r0,[sp,#0]
00007c  11a03006          MOVNE    r3,r6
000080  128f10c4          ADRNE    r1,|L10.332|
000084  128f0f41          ADRNE    r0,|L10.400|
;;;408    		return false;
000088  1a00002a          BNE      |L10.312|
00008c  ea000015          B        |L10.232|
                  |L10.144|
;;;409    	}
;;;410    	//DEBUG_PRINTF("L5\n"); 
;;;411    	 
;;;412    //	if (overrun_flag == 1) {
;;;413    //		result = file_write(&(fileState->logFile), strlen("ADXL overrun\n"), "ADXL overrun\n");
;;;414    //		overrun_flag = 0;
;;;415    
;;;416    
;;;417    
;;;418    #endif	
;;;419    
;;;420    	for (i = start; i < end; i++) {
;;;421    		/*DEBUG_PRINTF("sensorData[%d] = {t: %d, x: %d, y: %d, z: %d}\n",
;;;422    					i,
;;;423    					sensorState.sensorData[(i * SENSORDATASIZE)],
;;;424    					sensorState.sensorData[(i * SENSORDATASIZE)+1],
;;;425    					sensorState.sensorData[(i * SENSORDATASIZE)+2],
;;;426    					sensorState.sensorData[(i * SENSORDATASIZE)+3]);*/
;;;427    //		int t = sensorState.sensorData[i * SENSORDATASIZE];				   // (JWS) time not in buffer anymore
;;;428    
;;;429    		//snprintf(line, 49, "%02d:%02d:%02d:%02d,%d,%d,%d\n",
;;;430    		snprintf(line,49,"%d,%d,%d,%d\n",
000090  e59f112c          LDR      r1,|L10.452|
000094  e0840084          ADD      r0,r4,r4,LSL #1
000098  e0810080          ADD      r0,r1,r0,LSL #1
00009c  e1d030f8          LDRSH    r3,[r0,#8]
0000a0  e1d020f6          LDRSH    r2,[r0,#6]
0000a4  e1d010f4          LDRSH    r1,[r0,#4]
0000a8  e28d000c          ADD      r0,sp,#0xc
0000ac  e88d000e          STM      sp,{r1-r3}
0000b0  e1a03004          MOV      r3,r4
0000b4  e28f2f43          ADR      r2,|L10.456|
0000b8  e3a01031          MOV      r1,#0x31
0000bc  ebfffffe          BL       __2snprintf
;;;431    			//(t>>24)&255,(t>>16)&255,(t>>8)&255,t&255, 			 
;;;432    			i,
;;;433    			sensorState.sensorData[i * SENSORDATASIZE],
;;;434    			sensorState.sensorData[i * SENSORDATASIZE + 1],
;;;435    			sensorState.sensorData[i * SENSORDATASIZE + 2]);
;;;436    //		result = data_log(fileState, line);
;;;437    
;;;438    		result = file_write(&(fileState->logFile), strlen(line), line);
0000c0  e28d000c          ADD      r0,sp,#0xc
0000c4  ebfffffe          BL       strlen
0000c8  e1a01000          MOV      r1,r0
0000cc  e28d200c          ADD      r2,sp,#0xc
0000d0  e1a00008          MOV      r0,r8
0000d4  ebfffffe          BL       file_write
;;;439    
;;;440    		if (!result) {
0000d8  e3500000          CMP      r0,#0
;;;441    			DEBUG_PRINTF(">>> Error in writing to data log from batch_log\n");
0000dc  028f00f4          ADREQ    r0,|L10.472|
0000e0  0bfffffe          BLEQ     debug_printf
0000e4  e2844001          ADD      r4,r4,#1              ;420
                  |L10.232|
0000e8  e1540005          CMP      r4,r5                 ;420
0000ec  baffffe7          BLT      |L10.144|
0000f0  e1a00008          MOV      r0,r8                 ;420
;;;442    		}
;;;443    	} 
;;;444    //	t3 = T2VAL;
;;;445    
;;;446    #ifdef recording
;;;447    	if (T2VAL >= 20 ) {
;;;448    
;;;449    	T2LD = 0;			// Timer 2 load register = 0
;;;450    	T2CON = 0; 			// reset t2 timer back to zero
;;;451     	T2CON = 0x000005cf; // Enabled, 32.768 osc, count up, periodic (resets to zero at max), clock/3276
;;;452    
;;;453    //	T1LD = 0;
;;;454    //	T1CON = 0;			// reseit timer 1 back to zero
;;;455    //	T1CON = 0x000211c0;  // Enable T1, internal clock, count up, periodic, clock/1, event 1 = timer 1
;;;456    	// write out 1 second worth of file info..
;;;457    
;;;458    #endif
;;;459    
;;;460      	//DEBUG_PRINTF("L6\n");
;;;461    	result = file_fclose(&(fileState->logFile));
0000f4  ebfffffe          BL       file_fclose
;;;462    //	t4 = T2VAL;
;;;463    	//DEBUG_PRINTF("L7\n");
;;;464    	if (result) {
0000f8  e3500000          CMP      r0,#0
;;;465    		DEBUG_PRINTF("%s:%d batch_log(): failed on file_fclose(\"%s\") = %d\n", __FILE__, __LINE__, fileState->logFileName, result);
0000fc  159f2108          LDRNE    r2,|L10.524|
000100  158d0000          STRNE    r0,[sp,#0]
000104  11a03006          MOVNE    r3,r6
000108  128f103c          ADRNE    r1,|L10.332|
00010c  128f00fc          ADRNE    r0,|L10.528|
;;;466    		return false;
000110  1a000008          BNE      |L10.312|
000114  e1a00007          MOV      r0,r7
;;;467    	}
;;;468    	//DEBUG_PRINTF("L8\n");
;;;469    	result = fs_umount(&(fileState->efs.myFs));
000118  ebfffffe          BL       fs_umount
;;;470    	
;;;471    
;;;472    //	t5 = T2VAL;
;;;473    //	t4 = t5 - t1;
;;;474    	//DEBUG_PRINTF("L9\n");
;;;475    	if (result) {
00011c  e3500000          CMP      r0,#0
;;;476    		DEBUG_PRINTF("%s:%d batch_log(): failed on fs_umount() = %d\n", __FILE__, __LINE__, result);
;;;477    		return false;
;;;478    	}
;;;479    
;;;480    #ifdef recording
;;;481    		//DEBUG_PRINTF("L1\n");
;;;482    	result = efs_init(&(fileState->efs), 0);
;;;483    
;;;484    //	t1 = T2VAL;
;;;485    	//DEBUG_PRINTF("L2\n");
;;;486    	if (result) {
;;;487    		DEBUG_PRINTF("%s:%d batch_log(): failed on efs_init() = %d\n", __FILE__, __LINE__, result);
;;;488    		return false;
;;;489    	}
;;;490    	//DEBUG_PRINTF("L3 %s\n", fileState->logFileName);
;;;491    
;;;492    	result = file_fopen(&(fileState->logFile), &(fileState->efs.myFs), fileState->logFileName, 'a');
;;;493    
;;;494    //	t2 = T2VAL;
;;;495    	//DEBUG_PRINTF("L4\n");
;;;496    	if (result) {
;;;497    		DEBUG_PRINTF("%s:%d batch_log(): failed on file_fopen(\"%s\") = %d\n", __FILE__, __LINE__, fileState->logFileName, result);
;;;498    		return false;
;;;499    	}
;;;500    	//DEBUG_PRINTF("L5\n"); 
;;;501    
;;;502    
;;;503    	}		// bracket for if statement above
;;;504    
;;;505    #endif
;;;506    
;;;507    //	DEBUG_PRINTF("count t4 = %08x\n", t4);
;;;508    
;;;509    //  	T2CON = 0x00000500;
;;;510    
;;;511    	//DEBUG_PRINTF("LDONE\n");
;;;512    	return true;
000120  03a00001          MOVEQ    r0,#1
000124  0a000005          BEQ      |L10.320|
000128  e1a03000          MOV      r3,r0                 ;476
00012c  e3a02f77          MOV      r2,#0x1dc             ;476
000130  e28f1014          ADR      r1,|L10.332|
000134  e28f0f43          ADR      r0,|L10.584|
                  |L10.312|
000138  ebfffffe          BL       debug_printf
00013c  e3a00000          MOV      r0,#0                 ;477
                  |L10.320|
000140  e28dd040          ADD      sp,sp,#0x40           ;477
;;;513    }
000144  e8bd81f0          POP      {r4-r8,pc}
                  |L10.328|
                          DCD      0x0000018d
                  |L10.332|
00014c  646174616c6f67676572352e6300        DCB      "datalogger5.c",0
00015a  00                DCB      0
00015b  00                DCB      0
                  |L10.348|
00015c  25733a25642062617463685f6c6f6728293a206661696c6564206f6e206566735f696e69742829203d2025640a00        DCB      "%s:%d batch_log(): failed on efs_init() = %d\n",0
00018a  00                DCB      0
00018b  00                DCB      0
                  |L10.396|
                          DCD      0x00000197
                  |L10.400|
000190  25733a25642062617463685f6c6f6728293a206661696c6564206f6e2066696c655f666f70656e282225732229203d2025640a00        DCB      "%s:%d batch_log(): failed on file_fopen(""%s"") = %d\n",0
                  |L10.452|
                          DCD      ||.bss||
                  |L10.456|
0001c8  25642c25642c25642c25640a00        DCB      "%d,%d,%d,%d\n",0
0001d5  00                DCB      0
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L10.472|
0001d8  3e3e3e204572726f7220696e2077726974696e6720746f2064617461206c6f672066726f6d2062617463685f6c6f670a00        DCB      ">>> Error in writing to data log from batch_log\n",0
000209  00                DCB      0
00020a  00                DCB      0
00020b  00                DCB      0
                  |L10.524|
                          DCD      0x000001d1
                  |L10.528|
000210  25733a25642062617463685f6c6f6728293a206661696c6564206f6e2066696c655f66636c6f7365282225732229203d2025640a        DCB      "%s:%d batch_log(): failed on file_fclose(""%s"") = %d\n"
000244  00                DCB      0
000245  00                DCB      0
000246  00                DCB      0
000247  00                DCB      0
                  |L10.584|
000248  25733a25642062617463685f6c6f6728293a206661696c6564206f6e2066735f756d6f756e742829203d2025640a00        DCB      "%s:%d batch_log(): failed on fs_umount() = %d\n",0
000277  00                DCB      0
                          ENDP


                          AREA ||i.data_log||, CODE, READONLY, ALIGN=2

                  data_log PROC
;;;371    
;;;372    int data_log(FilesystemState *fileState, char *line) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;373    	int result = 0;
;;;374    	result = file_write(&(fileState->logFile), strlen(line), line);
00000c  e1a00001          MOV      r0,r1
000010  ebfffffe          BL       strlen
000014  e1a01000          MOV      r1,r0
000018  e2840b03          ADD      r0,r4,#0xc00
00001c  e1a02005          MOV      r2,r5
000020  e2800f59          ADD      r0,r0,#0x164
000024  ebfffffe          BL       file_write
;;;375    	return true;
000028  e3a00001          MOV      r0,#1
;;;376    }
00002c  e8bd8070          POP      {r4-r6,pc}
;;;377    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=2

                  delay PROC
;;;270    
;;;271    void delay (int length){
000000  e3500000          CMP      r0,#0
;;;272      while (length >=0)
;;;273        length--;
000004  a2400001          SUBGE    r0,r0,#1
000008  aafffffc          BGE      delay
;;;274    }
00000c  e12fff1e          BX       lr
;;;275    
                          ENDP


                          AREA ||i.greenLight||, CODE, READONLY, ALIGN=2

                  greenLight PROC
;;;688    
;;;689    void greenLight(bool state) {
000000  e3500000          CMP      r0,#0
000004  e3a02000          MOV      r2,#0
;;;690    	if (state) {
;;;691    		GP4SET = 1<<22;
000008  e3a01501          MOV      r1,#0x400000
;;;692    	} else {
;;;693    		GP4CLR = 1<<22;
00000c  05021b98          STREQ    r1,[r2,#-0xb98]
000010  15021b9c          STRNE    r1,[r2,#-0xb9c]       ;691
;;;694    	}
;;;695    }
000014  e12fff1e          BX       lr
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;126    
;;;127    int main() {
000000  e92d4010          PUSH     {r4,lr}
000004  e24ddee2          SUB      sp,sp,#0xe20
;;;128    	if (Initialize()) {
000008  ebfffffe          BL       Initialize
00000c  e3500000          CMP      r0,#0
;;;129    		FilesystemState fs;
;;;130    		
;;;131    //		sensorState.sensorData[SENSORBUFFERSIZE * SENSORDATASIZE -1] = 0xDEADBEEF;
;;;132    //		DEBUG_PRINTF("You wrote: 0x%08X\n",sensorState.sensorData[SENSORBUFFERSIZE * SENSORDATASIZE - 1]);
;;;133    //		DEBUG_PRINTF("Line 153: 0x%08X, 0x%08X, 0x%08X\n",sensorState.sensorData[153*SENSORDATASIZE],sensorState.sensorData[153*SENSORDATASIZE+1],sensorState.sensorData[153*SENSORDATASIZE+2]);
;;;134    //		DEBUG_PRINTF("Line 154: 0x%08X, 0x%08X, 0x%08X\n",sensorState.sensorData[154*SENSORDATASIZE],sensorState.sensorData[154*SENSORDATASIZE+1],sensorState.sensorData[154*SENSORDATASIZE+2]);
;;;135    //		DEBUG_PRINTF("Line 155: 0x%08X, 0x%08X, 0x%08X\n",sensorState.sensorData[155*SENSORDATASIZE],sensorState.sensorData[155*SENSORDATASIZE+1],sensorState.sensorData[155*SENSORDATASIZE+2]);
;;;136    
;;;137    		DEBUG_PRINTF(">>> Initialized ok\n");
;;;138    		if (InitFs(&fs)) {
;;;139    			DEBUG_PRINTF(">>> Initialized Filesystem ok\n");
;;;140    			SensorLoop(&fs);	   // Go to endless filesystem loop here
;;;141    		} else {
;;;142    			DEBUG_PRINTF("!!! Initialize Filesystem failed!\n");
;;;143    //			while (true);
;;;144    			
;;;145    		}
;;;146    
;;;147    	} else {
;;;148    		DEBUG_PRINTF("!!! Initialize failed!\n");
000010  028f004c          ADREQ    r0,|L14.100|
000014  0a00000c          BEQ      |L14.76|
000018  e28f005c          ADR      r0,|L14.124|
00001c  ebfffffe          BL       debug_printf
000020  e28d4008          ADD      r4,sp,#8              ;138
000024  e1a00004          MOV      r0,r4                 ;138
000028  ebfffffe          BL       InitFs
00002c  e3500000          CMP      r0,#0                 ;138
000030  0a000004          BEQ      |L14.72|
000034  e28f0054          ADR      r0,|L14.144|
000038  ebfffffe          BL       debug_printf
00003c  e1a00004          MOV      r0,r4                 ;140
000040  ebfffffe          BL       SensorLoop
000044  ea000001          B        |L14.80|
                  |L14.72|
000048  e28f0060          ADR      r0,|L14.176|
                  |L14.76|
00004c  ebfffffe          BL       debug_printf
                  |L14.80|
;;;149    		
;;;150    	}
;;;151    
;;;152    	greenLight(false);	
000050  e3a00000          MOV      r0,#0
000054  ebfffffe          BL       greenLight
;;;153    	redLight(true);
000058  e3a00001          MOV      r0,#1
00005c  ebfffffe          BL       redLight
                  |L14.96|
;;;154    	while (true);
000060  eafffffe          B        |L14.96|
;;;155    	return 0;
;;;156    }
;;;157    
                          ENDP

                  |L14.100|
000064  21212120496e697469616c697a65206661696c6564210a00        DCB      "!!! Initialize failed!\n",0
                  |L14.124|
00007c  3e3e3e20496e697469616c697a6564206f6b0a00        DCB      ">>> Initialized ok\n",0
                  |L14.144|
000090  3e3e3e20496e697469616c697a65642046696c6573797374656d206f6b0a00        DCB      ">>> Initialized Filesystem ok\n",0
0000af  00                DCB      0
                  |L14.176|
0000b0  21212120496e697469616c697a652046696c6573797374656d206661696c6564210a00        DCB      "!!! Initialize Filesystem failed!\n",0
0000d3  00                DCB      0

                          AREA ||i.redLight||, CODE, READONLY, ALIGN=2

                  redLight PROC
;;;680    
;;;681    void redLight(bool state) {
000000  e3500000          CMP      r0,#0
000004  e3a02000          MOV      r2,#0
;;;682    	if (state) {
;;;683    		GP4SET = 1<<21;
000008  e3a01602          MOV      r1,#0x200000
;;;684    	} else {
;;;685    		GP4CLR = 1<<21;
00000c  05021b98          STREQ    r1,[r2,#-0xb98]
000010  15021b9c          STRNE    r1,[r2,#-0xb9c]       ;683
;;;686    	}
;;;687    }
000014  e12fff1e          BX       lr
;;;688    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sensorState
                          %        2404

                          AREA ||.data||, DATA, ALIGN=2

                  overrun_flag
                          DCD      0x00000000
                  num_of_int
                          DCD      0x00000000
                  lastTime
                          DCD      0x00000000
                  xbuffer
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

                          AREA ||area_number.20||, DATA, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.data||
                  IRQ
                          DCD      0x00000000

                          AREA ||area_number.21||, DATA, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.data||
                  ||SWI||
                          DCD      0x00000000

                          AREA ||area_number.22||, DATA, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.data||
                  ||FIQ||
                          DCD      0x00000000

                          AREA ||area_number.23||, DATA, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.data||
                  UNDEF
                          DCD      0x00000000

                          AREA ||area_number.24||, DATA, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.data||
                  PABORT
                          DCD      0x00000000

                          AREA ||area_number.25||, DATA, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.data||
                  DABORT
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
